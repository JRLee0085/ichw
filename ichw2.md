## Task 1

### 1. 图灵为了说明不存在这样一个程序或算法，它能够计算任何程序或算法在给定的输入上是否会停机而引入了停机问题

### 2. 关于停机问题的证明：

首先所有图灵机可以编码成自然数，假设所有的图灵机被编码为M1,M2……号机，而应用在它们上的编码是<M1>,<M2>……则此时必会出现有些机器停机，而另一些不停机。假设情形如下（T代表停机，F代表不停机）

    
        <M1> <M2> <M3>   ...
    
    M1    F    T    T   ... 

    M2    F    T    F   ... 

    M3    T    F    T   ... 

    ...................
    
现在一个集合 D={输入运行<Mi>编码,机器Mi不停机}如上例，可知 D={<M1>, <M3>......}。

现在只要证明D不是任何图灵机的停机集合，便可证明或者说解决了停机问题

不妨假设集合D是某台图灵机M的停机集合，那么考虑以<M>作为输入来运行M，会出现两种情况
  
1. 如果停机，根据D的定义，<M>不是D的元素，D又是M的停机集合，因此以<M>作为输入来运行M不停机
  
2. 如果不停机，根据 D 的定义，<M>是 D 的元素，D 又是 M 的停机集合， 因此以<M>作为输入来运行 M 停机

不难发现，上述两种情况都自相矛盾，也就是说最初的假设不合理，也就说明D不是任何图灵机的停机集合，这也就说明集合D是无法被判定的，停机问题是无法被判定的

### 3.停机问题中涉及到的数学原理：康托尔的对角线原理，集合论以及反证法

## Task 2

### 二进制补码的原理如下：

首先不妨将补码这个抽象的事物推演到一个闹钟上，假如说你要订五点的闹钟（假定闹钟不分上下午），而现在指针指在12点的位置上，你该怎么调节，当然会有两种调节方式：
1. 顺时针转动五个格子
2. 逆时针转动七个格子

而5+7刚好=12 也就是说5与7互为12的补充

补码与此有异曲同工之妙

不过此时指针指在2^N处，这个值取决于码长N。
此时就必然会有两对数字互为补充，即A+B=2^N,这就是二进制补码的原理
